If you thought Touhou 6 remapping was hard, prepare yourself! th123 only uses dinput8 to check controller or keyboard! And it uses CoCreateInstance!

Q: Why not use dinput8.dll replacement?
A: Doesn't work with Steam input remapping.

The location where DInput writes its data is not static. But the location of where it gets written is kept in eax at instruction A1C7 (mov ecx,[eax]).

structure is 4 bytes for control stick X axis, 4 bytes for control stick Y axis, 4 bytes of nothing, 8 bytes for control stick x and y axis, 8 more bytes of nothing, then 4 bytes for the DPad.

control stick X and Y axis: 4 bytes signed, min -1000, max 1000

DPad:
no direction = -1 (FFFFFF)
up = 0 (000000)
right = 9000 (28 23 00 00)
down = 18000 (50 46 00 00)
left = 27000 (78 69 00 00)

upleft = 31500 (0C 7B 00 00)
upright = 4500 (94 11 00 00)
downright = 13500 (BC 34 00 00)
downleft = 22500 (E4 57 00 00)

As you can see, only 2 bytes are used and actually only 1 byte is needed.

Controller checking is done at A1C7.
After calling function to retrieve from location of eax, ecx is compared to 0, if not 0 then compare if ecx is less than -500, 
if less than 500 subtract from location of where the controller X Axis info is stored for the game, if greater than -500 then
add to it.
Y Axis data is also stored but th123 doesn't use it.

Current function:

.text:0040A1CC                 cmp     ecx, 0FFFFFE0Ch ; -500
.text:0040A1D2                 jge     short loc_40A1E1 ; jump if greater or equal to -500
.text:0040A1D4                 cmp     [esi+38h], edi  ; =/= 0
.text:0040A1D7                 jle     short SubControlXAxis
.text:0040A1D9                 mov     [esi+38h], edi
.text:0040A1DC
.text:0040A1DC SubControlXAxis:                        ; CODE XREF: sub_40A1A0+37↑j
.text:0040A1DC                 add     [esi+38h], edx
.text:0040A1DF                 jmp     short loc_40A1FA
.text:0040A1E1 ; ---------------------------------------------------------------------------
.text:0040A1E1
.text:0040A1E1 loc_40A1E1:                             ; CODE XREF: sub_40A1A0+32↑j
.text:0040A1E1                 cmp     ecx, 500
.text:0040A1E7                 jle     short ClrControlXAxis
.text:0040A1E9                 cmp     [esi+38h], edi  ; =/= 0
.text:0040A1EC                 jge     short AddControlXAxis
.text:0040A1EE
.text:0040A1EE ClrControlXAxis2:
.text:0040A1EE                 mov     [esi+38h], edi
.text:0040A1F1
.text:0040A1F1 AddControlXAxis:                        ; CODE XREF: sub_40A1A0+4C↑j
.text:0040A1F1                 add     dword ptr [esi+38h], 1
.text:0040A1F5                 jmp     short loc_40A1FA
.text:0040A1F7 ; ---------------------------------------------------------------------------
.text:0040A1F7
.text:0040A1F7 ClrControlXAxis:                        ; CODE XREF: sub_40A1A0+47↑j
.text:0040A1F7                 mov     [esi+38h], edi
.text:0040A1FA
.text:0040A1FA loc_40A1FA:                             ; CODE XREF: sub_40A1A0+3F↑j
.text:0040A1FA                                         ; sub_40A1A0+55↑j
.text:0040A1FA                 mov     ecx, [eax+4]
.text:0040A1FD                 cmp     ecx, 0FFFFFE0Ch
.text:0040A203                 jge     short loc_40A212
.text:0040A205                 cmp     [esi+3Ch], edi
.text:0040A208                 jle     short SubControlYAxis
.text:0040A20A                 mov     [esi+3Ch], edi
.text:0040A20D
.text:0040A20D SubControlYAxis:                        ; CODE XREF: sub_40A1A0+68↑j
.text:0040A20D                 add     [esi+3Ch], edx
.text:0040A210                 jmp     short loc_40A22B
.text:0040A212 ; ---------------------------------------------------------------------------
.text:0040A212
.text:0040A212 loc_40A212:                             ; CODE XREF: sub_40A1A0+63↑j
.text:0040A212                 cmp     ecx, 500
.text:0040A218                 jle     short ClrControlYAxis
.text:0040A21A                 cmp     [esi+3Ch], edi
.text:0040A21D                 jge     short AddControlYAxis
.text:0040A21F                 mov     [esi+3Ch], edi
.text:0040A222
.text:0040A222 AddControlYAxis:                        ; CODE XREF: sub_40A1A0+7D↑j
.text:0040A222                 add     dword ptr [esi+3Ch], 1
.text:0040A226                 jmp     short loc_40A22B
.text:0040A228 ; ---------------------------------------------------------------------------
.text:0040A228
.text:0040A228 ClrControlYAxis:                        ; CODE XREF: sub_40A1A0+78↑j
.text:0040A228                 mov     [esi+3Ch], edi

^ 5F, or 95 opcodes large according to IDA

add		[esi+3Ch], edx				<- 01 56 38, only 3 bytes!
add     dword ptr [esi+38h], 1		<- 83 46 38 01, 4 bytes

Maybe something can be done?

up = 0 (000000)
upright = 4500 (94 11 00 00)
right = 9000 (28 23 00 00)
down = 18000 (50 46 00 00)
downright = 13500 (BC 34 00 00)
downleft = 22500 (E4 57 00 00)
left = 27000 (78 69 00 00)
upleft = 31500 (0C 7B 00 00)
no direction = -1 (FFFFFF)

new function should be:
	mov		ecx, [eax+???]			;Don't know how much to shift yet
	or		edx, -1

	cmp		ecx,edi 				;optimization, edi is 0, takes less bytes than checking 0.
	js		short end				;if ecx was -1 (FF) jump to end
	jne		short checkUpleft		;if ecx != 0 (up) jump to checkUpleft
up:
	add     [esi+3C], edx			;subtract from y axis
	jmp		end
checkUpleft:
	cmp		cl, 0C					;upleft
	jle		short checkLeft
upLeft:
	add		[esi+3C], edx			;subtract from x axis
	add     [esi+3C], edx			;subtract from y axis
	jmp		short end
checkLeft:
	cmp 	cl, 78						;left
	jle 	short checkDownLeft
left:
	add		[esi+3C], edx			;subtract from x axis
	jmp		short end
checkDownLeft:
	cmp 	cl, E4					;downleft
	jle 	short checkDownright
downleft:
	add		[esi+3C], edx			;subtract from x axis
	add		dword ptr [esi+3C], 1	;add to y axis
	jmp		short end
checkDownright:
	cmp 	cl, BC
	jle		short checkDown
downright:
	add     dword ptr [esi+38], 1	;add to x axis
	add		dword ptr [esi+3C], 1	;add to y axis
	jmp		short end
checkDown:
	cmp		cl, 50
	jle		short checkRight
down:
	add		dword ptr [esi+3C], 1	;add to y axis
	jmp		short end
checkRight:
	cmp		cl, 28
	jle		short Upright			;No need to check upright because it's the last possible value.
right:
	add		dword ptr [esi+3C], 1	;add to y axis
	jmp		short end
Upright:
	add		[esi+3Ch], edx			;subtract from x axis
	add		dword ptr [esi+3C], 1	;add to y axis
